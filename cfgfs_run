#!/bin/sh

# wrapper script that starts cfgfs together with the game

if [ $# -eq 0 ]; then
	>&2 echo "usage: cfgfs_run [...] <game_executable> -game <dirname> [...]"
	>&2 echo "or rather, you're not meant to use this directly but by setting it in the launch options"
	exit 1
fi

>&2 echo "== cfgfs starting for app ${SteamAppId} =="

# pwd:
# [[/home/human/.local/share/Steam/steamapps/common/Team Fortress 2]]
# %command%:
# [['/home/human/.local/share/Steam/steamapps/common/Team Fortress 2/hl2.sh' -game tf -steam]]

# temporarily unset these to reduce warning spam
ld_library_path=$LD_LIBRARY_PATH; unset LD_LIBRARY_PATH
ld_preload=$LD_PRELOAD; unset LD_PRELOAD

if ! { t=$(realpath -- "$0") && t=$(dirname -- "$t"); }; then
	>&2 echo "cfgfs_run: failed to find the cfgfs directory!"
	exit 1
fi
if ! [ -f "$t/cfgfs" -a -x "$t/cfgfs" ]; then
	>&2 echo "cfgfs_run: cfgfs executable not found!"
	exit 1
fi

export CFGFS_STARTTIME="$(date +%s)"

cfgfs_dir=$t
cfgfs_mountpoint=
gamedir=
gameroot=$PWD

find_gamedir_from_cmdline() {
	while [ $# -ge 3 ]; do
		if [ -f "$1" -a -x "$1" ] && \
		   [ "$2" = "-game" ] && \
		   [ -d "$gameroot/$3" ] \
		; then
			gamedir=$gameroot/$3
			return 0
		fi
		shift
	done
	return 1
}
if ! find_gamedir_from_cmdline "$@"; then
	>&2 echo "cfgfs_run: -game parameter missing or not set to a valid value"
	exit 1
fi

# note: the "!cfgfs" name is hardcoded in other places too
gamedir_to_cfgfs_mount_path=custom/!cfgfs/cfg

cfgfs_mountpoint=$gamedir/$gamedir_to_cfgfs_mount_path

{
if ! cd "$cfgfs_dir"; then
	>&2 echo "cfgfs_run: failed to cd to the cfgfs directory!"
	exit 1
fi

# steam sets this to "C" which breaks unicode support in xterm
if [ "$LC_ALL" = "C" ]; then unset LC_ALL; fi

export GAMEDIR="$gamedir"
export GAMEROOT="$gameroot"

export CFGFS_MOUNTPOINT="$cfgfs_mountpoint"

# parse the game name from gameinfo.txt
if [ -f "$gamedir/gameinfo.txt" ] && \
   gamename=$(grep -Poim1 '^\s*(?:game\s|"game")\s*(?:"\K[^"]*(?=(?:"\s*)?$)|\K.*?(?=\s*$))' "$gamedir/gameinfo.txt") \
; then
	export GAMENAME="$gamename"
else
	>&2 echo "cfgfs_run: failed to parse game name from gameinfo.txt!"
	exit 1
fi

if [ -z "$CFGFS_SCRIPT" ]; then
	# note: SteamAppId is set by steam
	export CFGFS_SCRIPT=script_${SteamAppId}.lua
	if [ ! -e "$CFGFS_SCRIPT" ]; then
		{
		echo "-- cfgfs script for ${GAMENAME:-app id ${SteamAppId}}"
		echo ""
		echo "cmd.echo('cfgfs: script_${SteamAppId}.lua loaded')"
		} >>"$CFGFS_SCRIPT"
	fi
fi

export CFGFS_RUN_PID=$$
while true; do
	xterm \
	    -title "cfgfs (${GAMENAME:-App ID ${SteamAppId}})" \
	    -e /bin/sh cfgfs_failsafe.sh "$cfgfs_mountpoint"

	# is xterm even installed?
	if [ $? -ne 0 ] && ! command -v xterm >/dev/null; then
		>&2 echo "cfgfs_run: xterm not installed!"
		break
	fi

	for delay in "" 0.2; do
		if [ -n "$delay" ]; then command sleep "$delay"; fi

		# has cfgfs_run exited yet?
		if [ ! -e "/proc/$CFGFS_RUN_PID" ]; then
			exit 0
		fi
	done

	export CFGFS_RESTARTED=1
	export CFGFS_TERMINAL_CLOSED=1
done
} &
cfgfs_term_pid=$!

# check that cfgfs is up and running (not only up or running but both)
check_cfgfs_works() {
	# what does mountpoint -q say?
	# this uses stat(), which has a few problems
	# - it can freeze the "mountpoint" process in case the filesystem is
	#    running but unresponsive
	# - it can return a false result in case the cfgfs process has crashed
	#    but stat("/") was cached by the kernel
	# to avoid the hang, a short timeout is used here
	# to avoid the false result, a second check is done after this
	if timeout 0.1 mountpoint -q "$cfgfs_mountpoint"; then
		# test if we can open and close a file from the filesystem.
		# - this must be open() because stat() calls are cached
		# - opening and closing a config has no side effects if we don't
		#    read any data from it (source also likes opening and
		#    closing config files for fun)
		# - this must use timeout because the open() call can hang if
		#    the filesystem is in a bad state
		if F=$cfgfs_mountpoint/cfgfs/buffer.cfg timeout 0.1 sh -c 'exec <"$F"'; then
			# ok: opening and closing a file works, filesystem must
			#  be up (and running) now
			return 0
		else
			return 1
		fi
	else
		return 1
	fi
}

wait_cfgfs_ready() {
	iter=1
	while true; do
		if [ ! -e "/proc/$cfgfs_term_pid" ]; then
			>&2 echo "cfgfs_run: terminal process exited unexpectedly"
			return 1
		fi

		# is it working yet?
		if check_cfgfs_works; then
			return 0
		fi

		if [ $iter -le 10 ]; then
			# note: the built-in sleep in dash doesn't support
			#  fractional sleeping, use GNU sleep which does
			command sleep 0.1
		else
			sleep 1
		fi
		iter=$((iter+1))
	done
}

if ! wait_cfgfs_ready; then
	# unmount in case it's stuck or something. we're not going to launch the
	#  game anyway
	fusermount -u "$cfgfs_mountpoint" 2>/dev/null &
	exit 1
fi

link_console_log() {
	# if console.log is a real file, move it out of the way first
	if [ -f "$gamedir/console.log" -a ! -L "$gamedir/console.log" ]; then
		newname=$gamedir/console.log.old
		if [ -e "$newname" ]; then
			newname=$gamedir/console.log.$(date +%s)
		fi
		mv -fv "$gamedir/console.log" "$newname"
	fi

	if ! ln -sfv "$gamedir_to_cfgfs_mount_path/console.log" "$gamedir/console.log"; then
		>&2 echo "cfgfs_run: failed to symlink console.log!"
	fi
}
unlink_console_log() {
	if [ -L "$gamedir/console.log" ]; then
		rm -fv "$gamedir/console.log"
	fi
}

link_console_log

(
	if [ -n "$ld_library_path" ]; then export LD_LIBRARY_PATH="$ld_library_path"; fi
	if [ -n "$ld_preload" ]; then export LD_PRELOAD="$ld_preload"; fi

	# -condebug: redirect console output to console.log early
	exec "$@" \
	    -condebug \
	    +exec cfgfs/init
)
rv=$?
if [ $rv -ne 0 ]; then
	>&2 echo "cfgfs_run: game exited with status $rv"
fi

unlink_console_log

fusermount -u "$cfgfs_mountpoint" 2>/dev/null &

exit $rv
