#undef NDEBUG

#define FUSE_USE_VERSION 31

#include <assert.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <sys/param.h>
#include <sys/stat.h>

#include <fuse.h>

#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MAX_KEY_LEN 1

struct cfgfs_file {
	char *content;
};

static const char keys[][MAX_KEY_LEN + 1] = {
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
};
static lua_State *L = NULL;
static _Bool did_read_autoexec = 0;

static _Bool
key_exists(const char *k)
{
	unsigned i;

	for (i = 0; i < ARRAYSIZE(keys); i++) {
		if (strcmp(keys[i], k) == 0)
			return 1;
	}

	return 0;
}

/*
 * "/binds/+key.cfg" -> "+key"
 */
static char *
bind_cfg_get_name(const char *path)
{
	size_t len = strlen(path);
	char *r;

	if (len < strlen("/binds/.cfg"))
		return NULL;
	if (memcmp(path, "/binds/", strlen("/binds/")) != 0)
		return NULL;
	if (memcmp(path + len - strlen(".cfg"), ".cfg", strlen(".cfg")) != 0)
		return NULL;

	r = malloc(len - strlen("/binds/.cfg") + 1);
	memcpy(r, path + strlen("/binds/"), len - strlen("/binds/.cfg"));
	r[len - strlen("/binds/.cfg")] = '\0';
	return r;
}

static _Bool
bind_cfg_test_name(const char *path)
{
	size_t len = strlen(path);

	if (len < strlen("/binds/.cfg"))
		return 0;
	if (memcmp(path, "/binds/", strlen("/binds/")) != 0)
		return 0;
	if (memcmp(path + len - strlen(".cfg"), ".cfg", strlen(".cfg")) != 0)
		return 0;

	return 1;
}

static void *
cfgfs_init(struct fuse_conn_info *conn, struct fuse_config *cfg)
{
	L = luaL_newstate();
	assert(L != NULL);

	luaL_openlibs(L);

	assert(getenv("CFGFS_SCRIPT") != NULL);
	if (luaL_dofile(L, getenv("CFGFS_SCRIPT")) != 0) {
		const char *s = lua_tostring(L, 1);
		fprintf(stderr, "%s\n", s);
		abort();
	}

	lua_newtable(L);
	lua_setfield(L, LUA_REGISTRYINDEX, "file_contents");

	return NULL;
}

static void
cfgfs_destroy(void *private_data)
{
	lua_close(L);
}

static int
cfgfs_getattr(const char *path,
              struct stat *stbuf,
              struct fuse_file_info *fi)
{
	if (strcmp(path, "/") == 0)
		goto normal_dir;

	if (!did_read_autoexec && strcmp(path, "/autoexec.cfg") == 0)
		goto normal_file;

	if (strcmp(path, "/binds") == 0)
		goto normal_dir;
	if (bind_cfg_test_name(path))
		goto normal_file;

	return -ENOENT;
normal_dir:
	stbuf->st_mode = S_IFDIR | 0755;
	return 0;
normal_file:
	stbuf->st_mode = S_IFREG | 0644;
	return 0;
}

static int
cfgfs_open(const char *path,
           struct fuse_file_info *fi)
{
	if (!did_read_autoexec && strcmp(path, "/autoexec.cfg") == 0) {
		struct cfgfs_file *fh;
		fh = malloc(1);
		assert(fh != NULL);
		fi->direct_io = 1;
		fi->fh = (uint64_t) fh;
		return 0;
	}

	if (bind_cfg_test_name(path)) {
		struct cfgfs_file *fh;
		fh = malloc(1);
		assert(fh != NULL);
		fi->direct_io = 1;
		fi->fh = (uint64_t) fh;
		return 0;
	}

	return -ENOENT;
}

static int
cfgfs_read(const char *path,
           char *buf,
           size_t size,
           off_t offset,
           struct fuse_file_info *fi)
{
	struct cfgfs_file *fh = (struct cfgfs_file *) fi->fh;
	char *key = NULL;

	if ((strcmp(path, "/autoexec.cfg") == 0) ||
	    ((key = bind_cfg_get_name(path)) != NULL)) {
		
		lua_getfield(L, LUA_REGISTRYINDEX, "file_contents");	/* FC */
		lua_pushlightuserdata(L, fh);				/* FC ptr */
		lua_gettable(L, -2);					/* FC str */
		
		if (lua_isnil(L, -1)) {
			lua_pop(L, 1);				/* FC */

			if (key != NULL) {
				lua_pushlightuserdata(L, fh);	/* FC ptr */
				lua_getglobal(L, "keypress");	/* FC ptr fn */
				lua_pushstring(L, key + 1);	/* FC ptr fn s */
				lua_pushboolean(L, (key[0] == '+'));	/* FC ptr fn s b */
				lua_call(L, 2, 1);		/* FC ptr cnt */
			} else {
				did_read_autoexec = 1;
				lua_pushlightuserdata(L, fh);	/* FC ptr */
				char *buf = malloc(1024*1024), *p = buf;
				for (unsigned i = 0; i < ARRAYSIZE(keys); i++) {
					p += sprintf(p, "bind +%s \"exec binds/+%s\"\n", keys[i], keys[i]);
					p += sprintf(p, "bind -%s \"exec binds/-%s\"\n", keys[i], keys[i]);
				}
				p += sprintf(p, "exec autoexec\n");
				lua_pushstring(L, buf);		/* FC ptr cnt */
				free(buf);
			}

			lua_settable(L, -3);			/* FC */

			lua_pushlightuserdata(L, fh);		/* FC ptr */
			lua_gettable(L, -2);			/* FC str */
		}
		
		lua_remove(L, -2);			/* str */
		
		const char *s = lua_tostring(L, -1);
		size_t len = lua_objlen(L, -1);
		lua_pop(L, 1);
		
		free(key);
		
		if (offset >= len)
			return 0;
		
		memcpy(buf, s + offset, MIN(size, len - offset));
		return len;
	}

	return -ENOENT;
}

static int
cfgfs_readdir(const char *path,
              void *buf,
              fuse_fill_dir_t filler,
              off_t offset,
              struct fuse_file_info *file,
              enum fuse_readdir_flags flags)
{
	if (strcmp(path, "/") == 0) {
		filler(buf, ".", NULL, 0, 0);
		filler(buf, "..", NULL, 0, 0);
		if (!did_read_autoexec)
			filler(buf, "autoexec.cfg", NULL, 0, 0);
		filler(buf, "binds", NULL, 0, 0);
		return 0;
	}

	if (strcmp(path, "/binds") == 0) {
		filler(buf, ".", NULL, 0, 0);
		filler(buf, "..", NULL, 0, 0);
		for (unsigned i = 0; i < ARRAYSIZE(keys); i++) {
			char tmp[1 + MAX_KEY_LEN + 4 + 1];
			snprintf(tmp, sizeof(tmp), "+%s.cfg", keys[i]);
			filler(buf, tmp, NULL, 0, 0);
			snprintf(tmp, sizeof(tmp), "-%s.cfg", keys[i]);
			filler(buf, tmp, NULL, 0, 0);
		}
		return 0;
	}

	return -ENOENT;
}

static struct fuse_operations fs_oper = {
	.init    = cfgfs_init,
	.destroy = cfgfs_destroy,
	.getattr = cfgfs_getattr,
	.readdir = cfgfs_readdir,
	.read = cfgfs_read,
	.open = cfgfs_open,
};

int
main(int argc, char **argv)
{
	return fuse_main(argc, argv, &fs_oper, NULL);
}
